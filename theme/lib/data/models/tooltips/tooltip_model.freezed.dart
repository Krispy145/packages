// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'tooltip_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

TooltipModel _$TooltipModelFromJson(Map<String, dynamic> json) {
  return _TooltipModel.fromJson(json);
}

/// @nodoc
mixin _$TooltipModel {
  double? get height => throw _privateConstructorUsedError;
  @EdgeInsetsConverter()
  EdgeInsets? get padding => throw _privateConstructorUsedError;
  @EdgeInsetsConverter()
  EdgeInsets? get margin => throw _privateConstructorUsedError;
  double? get verticalOffset => throw _privateConstructorUsedError;
  bool? get preferBelow => throw _privateConstructorUsedError;
  bool? get excludeFromSemantics => throw _privateConstructorUsedError;
  @BoxDecorationConverter()
  Map<BoxBorderType, BoxDecoration?>? get decoration =>
      throw _privateConstructorUsedError;
  String? get textStyle =>
      throw _privateConstructorUsedError; //TODO: implement these converters
// TextAlign? textAlign,
// Duration? waitDuration,
// Duration? showDuration,
// TooltipTriggerMode? triggerMode,
  bool? get enableFeedback => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TooltipModelCopyWith<TooltipModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TooltipModelCopyWith<$Res> {
  factory $TooltipModelCopyWith(
          TooltipModel value, $Res Function(TooltipModel) then) =
      _$TooltipModelCopyWithImpl<$Res, TooltipModel>;
  @useResult
  $Res call(
      {double? height,
      @EdgeInsetsConverter() EdgeInsets? padding,
      @EdgeInsetsConverter() EdgeInsets? margin,
      double? verticalOffset,
      bool? preferBelow,
      bool? excludeFromSemantics,
      @BoxDecorationConverter() Map<BoxBorderType, BoxDecoration?>? decoration,
      String? textStyle,
      bool? enableFeedback});
}

/// @nodoc
class _$TooltipModelCopyWithImpl<$Res, $Val extends TooltipModel>
    implements $TooltipModelCopyWith<$Res> {
  _$TooltipModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? height = freezed,
    Object? padding = freezed,
    Object? margin = freezed,
    Object? verticalOffset = freezed,
    Object? preferBelow = freezed,
    Object? excludeFromSemantics = freezed,
    Object? decoration = freezed,
    Object? textStyle = freezed,
    Object? enableFeedback = freezed,
  }) {
    return _then(_value.copyWith(
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      padding: freezed == padding
          ? _value.padding
          : padding // ignore: cast_nullable_to_non_nullable
              as EdgeInsets?,
      margin: freezed == margin
          ? _value.margin
          : margin // ignore: cast_nullable_to_non_nullable
              as EdgeInsets?,
      verticalOffset: freezed == verticalOffset
          ? _value.verticalOffset
          : verticalOffset // ignore: cast_nullable_to_non_nullable
              as double?,
      preferBelow: freezed == preferBelow
          ? _value.preferBelow
          : preferBelow // ignore: cast_nullable_to_non_nullable
              as bool?,
      excludeFromSemantics: freezed == excludeFromSemantics
          ? _value.excludeFromSemantics
          : excludeFromSemantics // ignore: cast_nullable_to_non_nullable
              as bool?,
      decoration: freezed == decoration
          ? _value.decoration
          : decoration // ignore: cast_nullable_to_non_nullable
              as Map<BoxBorderType, BoxDecoration?>?,
      textStyle: freezed == textStyle
          ? _value.textStyle
          : textStyle // ignore: cast_nullable_to_non_nullable
              as String?,
      enableFeedback: freezed == enableFeedback
          ? _value.enableFeedback
          : enableFeedback // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TooltipModelImplCopyWith<$Res>
    implements $TooltipModelCopyWith<$Res> {
  factory _$$TooltipModelImplCopyWith(
          _$TooltipModelImpl value, $Res Function(_$TooltipModelImpl) then) =
      __$$TooltipModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? height,
      @EdgeInsetsConverter() EdgeInsets? padding,
      @EdgeInsetsConverter() EdgeInsets? margin,
      double? verticalOffset,
      bool? preferBelow,
      bool? excludeFromSemantics,
      @BoxDecorationConverter() Map<BoxBorderType, BoxDecoration?>? decoration,
      String? textStyle,
      bool? enableFeedback});
}

/// @nodoc
class __$$TooltipModelImplCopyWithImpl<$Res>
    extends _$TooltipModelCopyWithImpl<$Res, _$TooltipModelImpl>
    implements _$$TooltipModelImplCopyWith<$Res> {
  __$$TooltipModelImplCopyWithImpl(
      _$TooltipModelImpl _value, $Res Function(_$TooltipModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? height = freezed,
    Object? padding = freezed,
    Object? margin = freezed,
    Object? verticalOffset = freezed,
    Object? preferBelow = freezed,
    Object? excludeFromSemantics = freezed,
    Object? decoration = freezed,
    Object? textStyle = freezed,
    Object? enableFeedback = freezed,
  }) {
    return _then(_$TooltipModelImpl(
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      padding: freezed == padding
          ? _value.padding
          : padding // ignore: cast_nullable_to_non_nullable
              as EdgeInsets?,
      margin: freezed == margin
          ? _value.margin
          : margin // ignore: cast_nullable_to_non_nullable
              as EdgeInsets?,
      verticalOffset: freezed == verticalOffset
          ? _value.verticalOffset
          : verticalOffset // ignore: cast_nullable_to_non_nullable
              as double?,
      preferBelow: freezed == preferBelow
          ? _value.preferBelow
          : preferBelow // ignore: cast_nullable_to_non_nullable
              as bool?,
      excludeFromSemantics: freezed == excludeFromSemantics
          ? _value.excludeFromSemantics
          : excludeFromSemantics // ignore: cast_nullable_to_non_nullable
              as bool?,
      decoration: freezed == decoration
          ? _value._decoration
          : decoration // ignore: cast_nullable_to_non_nullable
              as Map<BoxBorderType, BoxDecoration?>?,
      textStyle: freezed == textStyle
          ? _value.textStyle
          : textStyle // ignore: cast_nullable_to_non_nullable
              as String?,
      enableFeedback: freezed == enableFeedback
          ? _value.enableFeedback
          : enableFeedback // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TooltipModelImpl extends _TooltipModel {
  const _$TooltipModelImpl(
      {this.height,
      @EdgeInsetsConverter() this.padding,
      @EdgeInsetsConverter() this.margin,
      this.verticalOffset,
      this.preferBelow,
      this.excludeFromSemantics,
      @BoxDecorationConverter()
      final Map<BoxBorderType, BoxDecoration?>? decoration,
      this.textStyle,
      this.enableFeedback})
      : _decoration = decoration,
        super._();

  factory _$TooltipModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$TooltipModelImplFromJson(json);

  @override
  final double? height;
  @override
  @EdgeInsetsConverter()
  final EdgeInsets? padding;
  @override
  @EdgeInsetsConverter()
  final EdgeInsets? margin;
  @override
  final double? verticalOffset;
  @override
  final bool? preferBelow;
  @override
  final bool? excludeFromSemantics;
  final Map<BoxBorderType, BoxDecoration?>? _decoration;
  @override
  @BoxDecorationConverter()
  Map<BoxBorderType, BoxDecoration?>? get decoration {
    final value = _decoration;
    if (value == null) return null;
    if (_decoration is EqualUnmodifiableMapView) return _decoration;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final String? textStyle;
//TODO: implement these converters
// TextAlign? textAlign,
// Duration? waitDuration,
// Duration? showDuration,
// TooltipTriggerMode? triggerMode,
  @override
  final bool? enableFeedback;

  @override
  String toString() {
    return 'TooltipModel(height: $height, padding: $padding, margin: $margin, verticalOffset: $verticalOffset, preferBelow: $preferBelow, excludeFromSemantics: $excludeFromSemantics, decoration: $decoration, textStyle: $textStyle, enableFeedback: $enableFeedback)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TooltipModelImpl &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.padding, padding) || other.padding == padding) &&
            (identical(other.margin, margin) || other.margin == margin) &&
            (identical(other.verticalOffset, verticalOffset) ||
                other.verticalOffset == verticalOffset) &&
            (identical(other.preferBelow, preferBelow) ||
                other.preferBelow == preferBelow) &&
            (identical(other.excludeFromSemantics, excludeFromSemantics) ||
                other.excludeFromSemantics == excludeFromSemantics) &&
            const DeepCollectionEquality()
                .equals(other._decoration, _decoration) &&
            (identical(other.textStyle, textStyle) ||
                other.textStyle == textStyle) &&
            (identical(other.enableFeedback, enableFeedback) ||
                other.enableFeedback == enableFeedback));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      height,
      padding,
      margin,
      verticalOffset,
      preferBelow,
      excludeFromSemantics,
      const DeepCollectionEquality().hash(_decoration),
      textStyle,
      enableFeedback);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TooltipModelImplCopyWith<_$TooltipModelImpl> get copyWith =>
      __$$TooltipModelImplCopyWithImpl<_$TooltipModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TooltipModelImplToJson(
      this,
    );
  }
}

abstract class _TooltipModel extends TooltipModel {
  const factory _TooltipModel(
      {final double? height,
      @EdgeInsetsConverter() final EdgeInsets? padding,
      @EdgeInsetsConverter() final EdgeInsets? margin,
      final double? verticalOffset,
      final bool? preferBelow,
      final bool? excludeFromSemantics,
      @BoxDecorationConverter()
      final Map<BoxBorderType, BoxDecoration?>? decoration,
      final String? textStyle,
      final bool? enableFeedback}) = _$TooltipModelImpl;
  const _TooltipModel._() : super._();

  factory _TooltipModel.fromJson(Map<String, dynamic> json) =
      _$TooltipModelImpl.fromJson;

  @override
  double? get height;
  @override
  @EdgeInsetsConverter()
  EdgeInsets? get padding;
  @override
  @EdgeInsetsConverter()
  EdgeInsets? get margin;
  @override
  double? get verticalOffset;
  @override
  bool? get preferBelow;
  @override
  bool? get excludeFromSemantics;
  @override
  @BoxDecorationConverter()
  Map<BoxBorderType, BoxDecoration?>? get decoration;
  @override
  String? get textStyle;
  @override //TODO: implement these converters
// TextAlign? textAlign,
// Duration? waitDuration,
// Duration? showDuration,
// TooltipTriggerMode? triggerMode,
  bool? get enableFeedback;
  @override
  @JsonKey(ignore: true)
  _$$TooltipModelImplCopyWith<_$TooltipModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
