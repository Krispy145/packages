// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'box_decoration_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

BoxDecorationModel _$BoxDecorationModelFromJson(Map<String, dynamic> json) {
  return _BoxDecorationModel.fromJson(json);
}

/// @nodoc
mixin _$BoxDecorationModel {
  String? get color => throw _privateConstructorUsedError;
  @BoxBorderConverter()
  Map<BoxBorderType, BoxBorder?>? get border =>
      throw _privateConstructorUsedError;
  @BorderRadiusConverter()
  BorderRadius? get borderRadius => throw _privateConstructorUsedError;
  @BoxShadowsConverter()
  List<BoxShadow>? get boxShadows => throw _privateConstructorUsedError;
  @GradientConverter()
  Gradient? get gradient => throw _privateConstructorUsedError;
  @BlendModeConverter()
  BlendMode? get backgroundBlendMode => throw _privateConstructorUsedError;
  @BoxShapeConverter()
  BoxShape? get shape => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BoxDecorationModelCopyWith<BoxDecorationModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BoxDecorationModelCopyWith<$Res> {
  factory $BoxDecorationModelCopyWith(
          BoxDecorationModel value, $Res Function(BoxDecorationModel) then) =
      _$BoxDecorationModelCopyWithImpl<$Res, BoxDecorationModel>;
  @useResult
  $Res call(
      {String? color,
      @BoxBorderConverter() Map<BoxBorderType, BoxBorder?>? border,
      @BorderRadiusConverter() BorderRadius? borderRadius,
      @BoxShadowsConverter() List<BoxShadow>? boxShadows,
      @GradientConverter() Gradient? gradient,
      @BlendModeConverter() BlendMode? backgroundBlendMode,
      @BoxShapeConverter() BoxShape? shape});
}

/// @nodoc
class _$BoxDecorationModelCopyWithImpl<$Res, $Val extends BoxDecorationModel>
    implements $BoxDecorationModelCopyWith<$Res> {
  _$BoxDecorationModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = freezed,
    Object? border = freezed,
    Object? borderRadius = freezed,
    Object? boxShadows = freezed,
    Object? gradient = freezed,
    Object? backgroundBlendMode = freezed,
    Object? shape = freezed,
  }) {
    return _then(_value.copyWith(
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
      border: freezed == border
          ? _value.border
          : border // ignore: cast_nullable_to_non_nullable
              as Map<BoxBorderType, BoxBorder?>?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadius?,
      boxShadows: freezed == boxShadows
          ? _value.boxShadows
          : boxShadows // ignore: cast_nullable_to_non_nullable
              as List<BoxShadow>?,
      gradient: freezed == gradient
          ? _value.gradient
          : gradient // ignore: cast_nullable_to_non_nullable
              as Gradient?,
      backgroundBlendMode: freezed == backgroundBlendMode
          ? _value.backgroundBlendMode
          : backgroundBlendMode // ignore: cast_nullable_to_non_nullable
              as BlendMode?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BoxDecorationModelImplCopyWith<$Res>
    implements $BoxDecorationModelCopyWith<$Res> {
  factory _$$BoxDecorationModelImplCopyWith(_$BoxDecorationModelImpl value,
          $Res Function(_$BoxDecorationModelImpl) then) =
      __$$BoxDecorationModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? color,
      @BoxBorderConverter() Map<BoxBorderType, BoxBorder?>? border,
      @BorderRadiusConverter() BorderRadius? borderRadius,
      @BoxShadowsConverter() List<BoxShadow>? boxShadows,
      @GradientConverter() Gradient? gradient,
      @BlendModeConverter() BlendMode? backgroundBlendMode,
      @BoxShapeConverter() BoxShape? shape});
}

/// @nodoc
class __$$BoxDecorationModelImplCopyWithImpl<$Res>
    extends _$BoxDecorationModelCopyWithImpl<$Res, _$BoxDecorationModelImpl>
    implements _$$BoxDecorationModelImplCopyWith<$Res> {
  __$$BoxDecorationModelImplCopyWithImpl(_$BoxDecorationModelImpl _value,
      $Res Function(_$BoxDecorationModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = freezed,
    Object? border = freezed,
    Object? borderRadius = freezed,
    Object? boxShadows = freezed,
    Object? gradient = freezed,
    Object? backgroundBlendMode = freezed,
    Object? shape = freezed,
  }) {
    return _then(_$BoxDecorationModelImpl(
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
      border: freezed == border
          ? _value._border
          : border // ignore: cast_nullable_to_non_nullable
              as Map<BoxBorderType, BoxBorder?>?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadius?,
      boxShadows: freezed == boxShadows
          ? _value._boxShadows
          : boxShadows // ignore: cast_nullable_to_non_nullable
              as List<BoxShadow>?,
      gradient: freezed == gradient
          ? _value.gradient
          : gradient // ignore: cast_nullable_to_non_nullable
              as Gradient?,
      backgroundBlendMode: freezed == backgroundBlendMode
          ? _value.backgroundBlendMode
          : backgroundBlendMode // ignore: cast_nullable_to_non_nullable
              as BlendMode?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BoxDecorationModelImpl extends _BoxDecorationModel {
  const _$BoxDecorationModelImpl(
      {this.color,
      @BoxBorderConverter() final Map<BoxBorderType, BoxBorder?>? border,
      @BorderRadiusConverter() this.borderRadius,
      @BoxShadowsConverter() final List<BoxShadow>? boxShadows,
      @GradientConverter() this.gradient,
      @BlendModeConverter() this.backgroundBlendMode,
      @BoxShapeConverter() this.shape = BoxShape.rectangle})
      : _border = border,
        _boxShadows = boxShadows,
        super._();

  factory _$BoxDecorationModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$BoxDecorationModelImplFromJson(json);

  @override
  final String? color;
  final Map<BoxBorderType, BoxBorder?>? _border;
  @override
  @BoxBorderConverter()
  Map<BoxBorderType, BoxBorder?>? get border {
    final value = _border;
    if (value == null) return null;
    if (_border is EqualUnmodifiableMapView) return _border;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  @BorderRadiusConverter()
  final BorderRadius? borderRadius;
  final List<BoxShadow>? _boxShadows;
  @override
  @BoxShadowsConverter()
  List<BoxShadow>? get boxShadows {
    final value = _boxShadows;
    if (value == null) return null;
    if (_boxShadows is EqualUnmodifiableListView) return _boxShadows;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @GradientConverter()
  final Gradient? gradient;
  @override
  @BlendModeConverter()
  final BlendMode? backgroundBlendMode;
  @override
  @JsonKey()
  @BoxShapeConverter()
  final BoxShape? shape;

  @override
  String toString() {
    return 'BoxDecorationModel(color: $color, border: $border, borderRadius: $borderRadius, boxShadows: $boxShadows, gradient: $gradient, backgroundBlendMode: $backgroundBlendMode, shape: $shape)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BoxDecorationModelImpl &&
            (identical(other.color, color) || other.color == color) &&
            const DeepCollectionEquality().equals(other._border, _border) &&
            (identical(other.borderRadius, borderRadius) ||
                other.borderRadius == borderRadius) &&
            const DeepCollectionEquality()
                .equals(other._boxShadows, _boxShadows) &&
            (identical(other.gradient, gradient) ||
                other.gradient == gradient) &&
            (identical(other.backgroundBlendMode, backgroundBlendMode) ||
                other.backgroundBlendMode == backgroundBlendMode) &&
            (identical(other.shape, shape) || other.shape == shape));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      color,
      const DeepCollectionEquality().hash(_border),
      borderRadius,
      const DeepCollectionEquality().hash(_boxShadows),
      gradient,
      backgroundBlendMode,
      shape);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BoxDecorationModelImplCopyWith<_$BoxDecorationModelImpl> get copyWith =>
      __$$BoxDecorationModelImplCopyWithImpl<_$BoxDecorationModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BoxDecorationModelImplToJson(
      this,
    );
  }
}

abstract class _BoxDecorationModel extends BoxDecorationModel {
  const factory _BoxDecorationModel(
      {final String? color,
      @BoxBorderConverter() final Map<BoxBorderType, BoxBorder?>? border,
      @BorderRadiusConverter() final BorderRadius? borderRadius,
      @BoxShadowsConverter() final List<BoxShadow>? boxShadows,
      @GradientConverter() final Gradient? gradient,
      @BlendModeConverter() final BlendMode? backgroundBlendMode,
      @BoxShapeConverter() final BoxShape? shape}) = _$BoxDecorationModelImpl;
  const _BoxDecorationModel._() : super._();

  factory _BoxDecorationModel.fromJson(Map<String, dynamic> json) =
      _$BoxDecorationModelImpl.fromJson;

  @override
  String? get color;
  @override
  @BoxBorderConverter()
  Map<BoxBorderType, BoxBorder?>? get border;
  @override
  @BorderRadiusConverter()
  BorderRadius? get borderRadius;
  @override
  @BoxShadowsConverter()
  List<BoxShadow>? get boxShadows;
  @override
  @GradientConverter()
  Gradient? get gradient;
  @override
  @BlendModeConverter()
  BlendMode? get backgroundBlendMode;
  @override
  @BoxShapeConverter()
  BoxShape? get shape;
  @override
  @JsonKey(ignore: true)
  _$$BoxDecorationModelImplCopyWith<_$BoxDecorationModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
